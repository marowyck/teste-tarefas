"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/to-dos/page",{

/***/ "(app-pages-browser)/./app/stores/useTasksStore.ts":
/*!*************************************!*\
  !*** ./app/stores/useTasksStore.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTasksStore: function() { return /* binding */ useTasksStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n\nconst useTasksStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set, get)=>{\n    return {\n        isTaskDialogOpened: false,\n        setIsTaskDialogOpened: (isDialogOpened)=>{\n            set({\n                isTaskDialogOpened: isDialogOpened\n            });\n        },\n        tasks: [],\n        isLoading: false,\n        setIsLoading: (isLoading)=>{\n            set({\n                isLoading\n            });\n        },\n        openDeleteDialog: false,\n        setOpenDeleteDialog: (openDeleteDialog)=>{\n            set({\n                openDeleteDialog: openDeleteDialog\n            });\n        },\n        taskSelected: null,\n        setTaskSelected: (task)=>{\n            set({\n                taskSelected: task\n            });\n        },\n        setTasks: (tasks)=>{\n            set({\n                tasks\n            });\n        },\n        addNewTask: async (task)=>{\n            try {\n                set({\n                    isLoading: true\n                });\n                const currentTasks = get().tasks;\n                const response = await fetch(\"/api/tasks\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(task)\n                });\n                const results = await response.json();\n                if (!results.success) {\n                    throw new Error(results.message);\n                }\n                const updatedTasks = [\n                    ...currentTasks,\n                    task\n                ];\n                set({\n                    tasks: sortTasksByCompleted(updatedTasks)\n                });\n                return {\n                    success: true,\n                    message: \"Tarefa adicionada com sucesso\",\n                    task\n                };\n            } catch (error) {\n                console.log(error);\n                return {\n                    success: false,\n                    message: \"Erro ao adicionar tarefa\",\n                    task\n                };\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        fetchTasks: async (user)=>{\n            try {\n                set({\n                    isLoading: true\n                });\n                if (!user) {\n                    return {\n                        success: false,\n                        message: \"ID do usu\\xe1rio definido\"\n                    };\n                }\n                console.log(user);\n                const response = await fetch(\"/api/tasks?userId=\".concat(user.id), {\n                    method: \"GET\"\n                });\n                const results = await response.json();\n                if (!results.success || !results.tasks) {\n                    return {\n                        success: false,\n                        message: \"Erro ao obter tarefa\"\n                    };\n                }\n                set({\n                    tasks: sortTasksByCompleted(results.tasks)\n                });\n                return {\n                    success: true,\n                    message: \"Tarefa obtida com sucesso\"\n                };\n            } catch (error) {\n                console.error(\"Erro ao obter tarefas:\", error);\n                return {\n                    success: false,\n                    message: \"Erro ao obter tarefa\"\n                };\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        deleteTaskFunction: async (option, user, task)=>{\n            try {\n                set({\n                    isLoading: true\n                });\n                if (!user) {\n                    return {\n                        success: false,\n                        message: \"Usu\\xe1rio n\\xe3o definido\"\n                    };\n                }\n                const response = await fetch(\"/api/tasks?userId=\".concat(user.id), {\n                    method: \"DELETE\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        option: option,\n                        task: task\n                    })\n                });\n                const results = await response.json();\n                if (!results.success) {\n                    return {\n                        success: false,\n                        message: results.message\n                    };\n                }\n                const currentTasks = get().tasks;\n                if (option === \"delete\" && task) {\n                    const updatedTasks = currentTasks.filter((t)=>t.id !== task.id);\n                    set({\n                        tasks: sortTasksByCompleted(updatedTasks)\n                    });\n                }\n                if (option === \"deleteAll\") {\n                    set({\n                        tasks: []\n                    });\n                }\n                return {\n                    success: true,\n                    message: results.message\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    message: \"Erro ao deletar: \".concat(error)\n                };\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        updateTaskFunction: async (task)=>{\n            try {\n                set({\n                    isLoading: true\n                });\n                const response = await fetch(\"/api/tasks\", {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(task)\n                });\n                const results = await response.json();\n                if (!results.success) {\n                    return {\n                        success: false,\n                        message: \"Erro ao atualizar\"\n                    };\n                }\n                const currentTasks = get().tasks;\n                const updatedTasks = currentTasks.map((t)=>t.id === task.id ? {\n                        ...t,\n                        ...task\n                    } : t);\n                set({\n                    tasks: sortTasksByCompleted(updatedTasks)\n                });\n                return {\n                    success: true,\n                    message: \"Tarefa atualizada com sucesso\"\n                };\n            } catch (error) {\n                return {\n                    success: false,\n                    message: \"Erro ao atualizar, \".concat(error)\n                };\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        }\n    };\n});\nfunction sortTasksByCompleted(tasks) {\n    const sortedTasks = tasks.sort((a, b)=>{\n        if (a.status === \"in progress\" && b.status !== \"in progress\") {\n            return -1;\n        }\n        if (a.status !== \"in progress\" && b.status === \"in progress\") {\n            return 1;\n        }\n        return 0;\n    });\n    return sortedTasks;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdG9yZXMvdXNlVGFza3NTdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQThCMUIsTUFBTUMsZ0JBQWdCRCwrQ0FBTUEsQ0FBeUIsQ0FBQ0UsS0FBS0M7SUFDaEUsT0FBTztRQUNMQyxvQkFBb0I7UUFDcEJDLHVCQUF1QixDQUFDQztZQUN0QkosSUFBSTtnQkFBRUUsb0JBQW9CRTtZQUFlO1FBQzNDO1FBQ0FDLE9BQU8sRUFBRTtRQUNUQyxXQUFXO1FBQ1hDLGNBQWMsQ0FBQ0Q7WUFDYk4sSUFBSTtnQkFBRU07WUFBVTtRQUNsQjtRQUVBRSxrQkFBa0I7UUFDbEJDLHFCQUFxQixDQUFDRDtZQUNwQlIsSUFBSTtnQkFBRVEsa0JBQWtCQTtZQUFpQjtRQUMzQztRQUVBRSxjQUFjO1FBQ2RDLGlCQUFpQixDQUFDQztZQUNoQlosSUFBSTtnQkFBRVUsY0FBY0U7WUFBSztRQUMzQjtRQUVBQyxVQUFVLENBQUNSO1lBQ1RMLElBQUk7Z0JBQUVLO1lBQU07UUFDZDtRQUVBUyxZQUFZLE9BQ1ZGO1lBRUEsSUFBSTtnQkFDRlosSUFBSTtvQkFBRU0sV0FBVztnQkFBSztnQkFDdEIsTUFBTVMsZUFBZWQsTUFBTUksS0FBSztnQkFFaEMsTUFBTVcsV0FBVyxNQUFNQyxNQUFNLGNBQWM7b0JBQ3pDQyxRQUFRO29CQUNSQyxTQUFTO3dCQUNQLGdCQUFnQjtvQkFDbEI7b0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3ZCO2dCQUVBLE1BQU1XLFVBQ0osTUFBTVAsU0FBU1EsSUFBSTtnQkFFckIsSUFBSSxDQUFDRCxRQUFRRSxPQUFPLEVBQUU7b0JBQ3BCLE1BQU0sSUFBSUMsTUFBTUgsUUFBUUksT0FBTztnQkFDakM7Z0JBRUEsTUFBTUMsZUFBZTt1QkFBSWI7b0JBQWNIO2lCQUFLO2dCQUU1Q1osSUFBSTtvQkFBRUssT0FBT3dCLHFCQUFxQkQ7Z0JBQWM7Z0JBRWhELE9BQU87b0JBQUVILFNBQVM7b0JBQU1F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QkFDUCxnQkFBZ0I7b0JBQ2xCO29CQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNWO2dCQUN2QjtnQkFFQSxNQUFNVyxVQUNKLE1BQU1QLFNBQVNRLElBQUk7Z0JBRXJCLElBQUksQ0FBQ0QsUUFBUUUsT0FBTyxFQUFFO29CQUNwQixPQUFPO3dCQUFFQSxTQUFTO3dCQUFPRSxTQUFVO29CQUFtQjtnQkFDeEQ7Z0JBRUEsTUFBTVosZUFBZWQsTUFBTUksS0FBSztnQkFFaEMsTUFBTXVCLGVBQWViLGFBQWEwQixHQUFHLENBQUMsQ0FBQ0YsSUFDckNBLEVBQUVKLEVBQUUsS0FBS3ZCLEtBQUt1QixFQUFFLEdBQUc7d0JBQUUsR0FBR0ksQ0FBQzt3QkFBRSxHQUFHM0IsSUFBSTtvQkFBQyxJQUFJMkI7Z0JBR3pDdkMsSUFBSTtvQkFBRUssT0FBT3dCLHFCQUFxQkQ7Z0JBQWM7Z0JBRWhELE9BQU87b0JBQUVILFNBQVM7b0JBQU1FLFNBQVM7Z0JBQWdDO1lBQ25FLEVBQUUsT0FBT0csT0FBTztnQkFDZCxPQUFPO29CQUFFTCxTQUFTO29CQUFPRSxTQUFTLHNCQUE0QixPQUFORztnQkFBUTtZQUNsRSxTQUFVO2dCQUNSOUIsSUFBSTtvQkFBRU0sV0FBVztnQkFBTTtZQUN6QjtRQUNGO0lBQ0Y7QUFDRixHQUFHO0FBRUgsU0FBU3VCLHFCQUFxQnhCLEtBQWE7SUFDekMsTUFBTXFDLGNBQWNyQyxNQUFNc0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ2pDLElBQUlELEVBQUVFLE1BQU0sS0FBSyxpQkFBaUJELEVBQUVDLE1BQU0sS0FBSyxlQUFlO1lBQzVELE9BQU8sQ0FBQztRQUNWO1FBQ0EsSUFBSUYsRUFBRUUsTUFBTSxLQUFLLGlCQUFpQkQsRUFBRUMsTUFBTSxLQUFLLGVBQWU7WUFDNUQsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0o7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc3RvcmVzL3VzZVRhc2tzU3RvcmUudHM/YzRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gXCIuLi9kYXRhL1Rhc2tzXCI7XG5cbmludGVyZmFjZSB1c2VUYXNrc1N0b3JlSW50ZXJmYWNlIHtcbiAgaXNUYXNrRGlhbG9nT3BlbmVkOiBib29sZWFuO1xuICBzZXRJc1Rhc2tEaWFsb2dPcGVuZWQ6IChpc1Rhc2tEaWFsb2dPcGVuZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHRhc2tTZWxlY3RlZDogVGFzayB8IG51bGw7XG4gIHNldFRhc2tTZWxlY3RlZDogKHRhc2s6IFRhc2sgfCBudWxsKSA9PiB2b2lkO1xuICB0YXNrczogVGFza1tdO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHNldElzTG9hZGluZzogKGlzTG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgb3BlbkRlbGV0ZURpYWxvZzogYm9vbGVhbjtcbiAgc2V0T3BlbkRlbGV0ZURpYWxvZzogKGlzVGFza0RpYWxvZ09wZW5lZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0VGFza3M6ICh0YXNrczogVGFza1tdKSA9PiB2b2lkO1xuICBmZXRjaFRhc2tzOiAoXG4gICAgdXNlcklkOiB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfSB8IG51bGxcbiAgKSA9PiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nIH0+O1xuICB1cGRhdGVUYXNrRnVuY3Rpb246IChcbiAgICB0YXNrOiBUYXNrXG4gICkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PjtcbiAgZGVsZXRlVGFza0Z1bmN0aW9uOiAoXG4gICAgb3B0aW9uOiBcImRlbGV0ZVwiIHwgXCJkZWxldGVBbGxcIixcbiAgICB1c2VyOiB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfSB8IG51bGwsXG4gICAgdGFzaz86IFRhc2sgXG4gICkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PjtcbiAgYWRkTmV3VGFzazogKFxuICAgIHRhc2s6IFRhc2tcbiAgKSA9PiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nOyB0YXNrOiBUYXNrIH0+O1xufVxuXG5leHBvcnQgY29uc3QgdXNlVGFza3NTdG9yZSA9IGNyZWF0ZTx1c2VUYXNrc1N0b3JlSW50ZXJmYWNlPigoc2V0LCBnZXQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpc1Rhc2tEaWFsb2dPcGVuZWQ6IGZhbHNlLFxuICAgIHNldElzVGFza0RpYWxvZ09wZW5lZDogKGlzRGlhbG9nT3BlbmVkOiBib29sZWFuKSA9PiB7XG4gICAgICBzZXQoeyBpc1Rhc2tEaWFsb2dPcGVuZWQ6IGlzRGlhbG9nT3BlbmVkIH0pO1xuICAgIH0sXG4gICAgdGFza3M6IFtdLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgc2V0SXNMb2FkaW5nOiAoaXNMb2FkaW5nOiBib29sZWFuKSA9PiB7XG4gICAgICBzZXQoeyBpc0xvYWRpbmcgfSk7XG4gICAgfSxcblxuICAgIG9wZW5EZWxldGVEaWFsb2c6IGZhbHNlLFxuICAgIHNldE9wZW5EZWxldGVEaWFsb2c6IChvcGVuRGVsZXRlRGlhbG9nOiBib29sZWFuKSA9PiB7XG4gICAgICBzZXQoeyBvcGVuRGVsZXRlRGlhbG9nOiBvcGVuRGVsZXRlRGlhbG9nIH0pO1xuICAgIH0sXG5cbiAgICB0YXNrU2VsZWN0ZWQ6IG51bGwsXG4gICAgc2V0VGFza1NlbGVjdGVkOiAodGFzazogVGFzayB8IG51bGwpID0+IHtcbiAgICAgIHNldCh7IHRhc2tTZWxlY3RlZDogdGFzayB9KTtcbiAgICB9LFxuXG4gICAgc2V0VGFza3M6ICh0YXNrczogVGFza1tdKSA9PiB7XG4gICAgICBzZXQoeyB0YXNrcyB9KTtcbiAgICB9LFxuXG4gICAgYWRkTmV3VGFzazogYXN5bmMgKFxuICAgICAgdGFzazogVGFza1xuICAgICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmc7IHRhc2s6IFRhc2sgfT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjdXJyZW50VGFza3MgPSBnZXQoKS50YXNrcztcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS90YXNrc1wiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2spLCBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0czogeyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfSA9XG4gICAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGlmICghcmVzdWx0cy5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdHMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkVGFza3MgPSBbLi4uY3VycmVudFRhc2tzLCB0YXNrXTtcblxuICAgICAgICBzZXQoeyB0YXNrczogc29ydFRhc2tzQnlDb21wbGV0ZWQodXBkYXRlZFRhc2tzKSB9KTtcblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIlRhcmVmYSBhZGljaW9uYWRhIGNvbSBzdWNlc3NvXCIsIHRhc2sgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiRXJybyBhbyBhZGljaW9uYXIgdGFyZWZhXCIsIHRhc2sgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZldGNoVGFza3M6IGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiSUQgZG8gdXN1w6FyaW8gZGVmaW5pZG9cIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2codXNlcik7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS90YXNrcz91c2VySWQ9JHt1c2VyLmlkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IHsgdGFza3M/OiBUYXNrW107IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9ID1cbiAgICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHRzLnN1Y2Nlc3MgfHwgIXJlc3VsdHMudGFza3MpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJFcnJvIGFvIG9idGVyIHRhcmVmYVwiIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZXQoeyB0YXNrczogc29ydFRhc2tzQnlDb21wbGV0ZWQocmVzdWx0cy50YXNrcykgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogXCJUYXJlZmEgb2J0aWRhIGNvbSBzdWNlc3NvXCIgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIG9idGVyIHRhcmVmYXM6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiRXJybyBhbyBvYnRlciB0YXJlZmFcIiB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlVGFza0Z1bmN0aW9uOiBhc3luYyAoXG4gICAgICBvcHRpb246IFwiZGVsZXRlXCIgfCBcImRlbGV0ZUFsbFwiLFxuICAgICAgdXNlcixcbiAgICAgIHRhc2s/OiBUYXNrXG4gICAgKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiVXN1w6FyaW8gbsOjbyBkZWZpbmlkb1wiIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Rhc2tzP3VzZXJJZD0ke3VzZXIuaWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgb3B0aW9uOiBvcHRpb24sIHRhc2s6IHRhc2sgfSksIFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHRzOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9ID1cbiAgICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHRzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogcmVzdWx0cy5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50VGFza3MgPSBnZXQoKS50YXNrcztcblxuICAgICAgICBpZiAob3B0aW9uID09PSBcImRlbGV0ZVwiICYmIHRhc2spIHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVGFza3MgPSBjdXJyZW50VGFza3MuZmlsdGVyKCh0KSA9PiB0LmlkICE9PSB0YXNrLmlkKTtcbiAgICAgICAgICBzZXQoeyB0YXNrczogc29ydFRhc2tzQnlDb21wbGV0ZWQodXBkYXRlZFRhc2tzKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb24gPT09IFwiZGVsZXRlQWxsXCIpIHtcbiAgICAgICAgICBzZXQoeyB0YXNrczogW10gfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiByZXN1bHRzLm1lc3NhZ2UgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBgRXJybyBhbyBkZWxldGFyOiAke2Vycm9yfWAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVRhc2tGdW5jdGlvbjogYXN5bmMgKHRhc2s6IFRhc2spID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS90YXNrc1wiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFzayksIFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHRzOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9ID1cbiAgICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHRzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYEVycm8gYW8gYXR1YWxpemFyYCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRhc2tzID0gZ2V0KCkudGFza3M7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFRhc2tzID0gY3VycmVudFRhc2tzLm1hcCgodCkgPT5cbiAgICAgICAgICB0LmlkID09PSB0YXNrLmlkID8geyAuLi50LCAuLi50YXNrIH0gOiB0XG4gICAgICAgICk7XG5cbiAgICAgICAgc2V0KHsgdGFza3M6IHNvcnRUYXNrc0J5Q29tcGxldGVkKHVwZGF0ZWRUYXNrcykgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogXCJUYXJlZmEgYXR1YWxpemFkYSBjb20gc3VjZXNzb1wiIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYEVycm8gYW8gYXR1YWxpemFyLCAke2Vycm9yfWAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBzb3J0VGFza3NCeUNvbXBsZXRlZCh0YXNrczogVGFza1tdKTogVGFza1tdIHtcbiAgY29uc3Qgc29ydGVkVGFza3MgPSB0YXNrcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc3RhdHVzID09PSBcImluIHByb2dyZXNzXCIgJiYgYi5zdGF0dXMgIT09IFwiaW4gcHJvZ3Jlc3NcIikge1xuICAgICAgcmV0dXJuIC0xOyBcbiAgICB9XG4gICAgaWYgKGEuc3RhdHVzICE9PSBcImluIHByb2dyZXNzXCIgJiYgYi5zdGF0dXMgPT09IFwiaW4gcHJvZ3Jlc3NcIikge1xuICAgICAgcmV0dXJuIDE7IFxuICAgIH1cbiAgICByZXR1cm4gMDsgXG4gIH0pO1xuXG4gIHJldHVybiBzb3J0ZWRUYXNrcztcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJ1c2VUYXNrc1N0b3JlIiwic2V0IiwiZ2V0IiwiaXNUYXNrRGlhbG9nT3BlbmVkIiwic2V0SXNUYXNrRGlhbG9nT3BlbmVkIiwiaXNEaWFsb2dPcGVuZWQiLCJ0YXNrcyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsIm9wZW5EZWxldGVEaWFsb2ciLCJzZXRPcGVuRGVsZXRlRGlhbG9nIiwidGFza1NlbGVjdGVkIiwic2V0VGFza1NlbGVjdGVkIiwidGFzayIsInNldFRhc2tzIiwiYWRkTmV3VGFzayIsImN1cnJlbnRUYXNrcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHRzIiwianNvbiIsInN1Y2Nlc3MiLCJFcnJvciIsIm1lc3NhZ2UiLCJ1cGRhdGVkVGFza3MiLCJzb3J0VGFza3NCeUNvbXBsZXRlZCIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImZldGNoVGFza3MiLCJ1c2VyIiwiaWQiLCJkZWxldGVUYXNrRnVuY3Rpb24iLCJvcHRpb24iLCJmaWx0ZXIiLCJ0IiwidXBkYXRlVGFza0Z1bmN0aW9uIiwibWFwIiwic29ydGVkVGFza3MiLCJzb3J0IiwiYSIsImIiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/stores/useTasksStore.ts\n"));

/***/ })

});